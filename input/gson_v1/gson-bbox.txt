/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.Since;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link VersionExclusionStrategy} class. * * @author Joel Leitch */public class VersionExclusionStrategyTest extends TestCase {  private static final double VERSION = 5.0D;  public void testDisallowNegativeValuesAndFailFast() throws Exception {    try {      new VersionExclusionStrategy(-1.0D);      fail("should have thrown an exception.");    } catch (IllegalArgumentException expected) { }  }  public void testClassAndFieldAreAtSameVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION);        assertFalse(strategy.shouldSkipClass(clazz));    assertFalse(strategy.shouldSkipField(f));  }  public void testClassAndFieldAreBehindInVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION + 1);        assertFalse(strategy.shouldSkipClass(clazz));    assertFalse(strategy.shouldSkipField(f));  }  public void testClassAndFieldAreAheadInVersion() throws Exception {    Class<MockObject> clazz = MockObject.class;    Field f = clazz.getField("someField");    VersionExclusionStrategy strategy = new VersionExclusionStrategy(VERSION - 1);        assertTrue(strategy.shouldSkipClass(clazz));    assertTrue(strategy.shouldSkipField(f));  }  @Since(VERSION)  private static class MockObject {    @Since(VERSION)    public final int someField = 0;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.TestTypes.ArrayOfArrays;import com.google.gson.TestTypes.ArrayOfObjects;import com.google.gson.TestTypes.BagOfPrimitiveWrappers;import com.google.gson.TestTypes.BagOfPrimitives;import com.google.gson.TestTypes.ClassWithCustomTypeConverter;import com.google.gson.TestTypes.ClassWithEnumFields;import com.google.gson.TestTypes.ClassWithExposedFields;import com.google.gson.TestTypes.ClassWithNoFields;import com.google.gson.TestTypes.ClassWithPrivateNoArgsConstructor;import com.google.gson.TestTypes.ClassWithSubInterfacesOfCollection;import com.google.gson.TestTypes.ClassWithTransientFields;import com.google.gson.TestTypes.ContainsReferenceToSelfType;import com.google.gson.TestTypes.MyEnum;import com.google.gson.TestTypes.MyEnumCreator;import com.google.gson.TestTypes.MyParameterizedType;import com.google.gson.TestTypes.Nested;import com.google.gson.TestTypes.PrimitiveArray;import com.google.gson.TestTypes.SubTypeOfNested;import com.google.gson.common.MoreAsserts;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.net.URI;import java.net.URL;import java.util.Collection;import java.util.Iterator;import java.util.List;import java.util.Locale;import java.util.Map;/** * Small test for Json Deserialization * * @author Inderjeet Singh * @author Joel Leitch */public class JsonDeserializerTest extends TestCase {  private Gson gson = null;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testInvalidJson() throws Exception {    try {      gson.fromJson("adfasdf1112,,,\":", BagOfPrimitives.class);      fail("Bad JSON should throw a ParseException");    } catch (JsonParseException expected) { }    try {      gson.fromJson("{adfasdf1112,,,\":}", BagOfPrimitives.class);      fail("Bad JSON should throw a ParseException");    } catch (JsonParseException expected) { }  }  public void testBagOfPrimitives() {    BagOfPrimitives src = new BagOfPrimitives(10, 20, false, "stringValue");    String json = src.getExpectedJson();    BagOfPrimitives target = gson.fromJson(json, BagOfPrimitives.class);    assertEquals(json, target.getExpectedJson());  }  public void testStringValue() throws Exception {    String value = "someRandomStringValue";    String actual = gson.fromJson("\"" + value + "\"", String.class);    assertEquals(value, actual);  }  @SuppressWarnings("unchecked")  public void testRawCollectionOfBagOfPrimitives() {    try {      BagOfPrimitives bag = new BagOfPrimitives(10, 20, false, "stringValue");      String json = '[' + bag.getExpectedJson() + ',' + bag.getExpectedJson() + ']';      Collection target = gson.fromJson(json, Collection.class);      assertEquals(2, target.size());      for (BagOfPrimitives bag1 : (Collection<BagOfPrimitives>) target) {        assertEquals(bag.getExpectedJson(), bag1.getExpectedJson());      }      fail("Raw collection of objects should not work");    } catch (JsonParseException expected) {    }  }  public void testReallyLongValues() {    String json = "333961828784581";    long value = gson.fromJson(json, Long.class);    assertEquals(333961828784581L, value);  }  public void testStringValueAsSingleElementArray() throws Exception {    String value = "someRandomStringValue";    String actual = gson.fromJson("[\"" + value + "\"]", String.class);    assertEquals(value, actual);  }  public void testPrimitiveLongAutoboxed() {    long expected = 1L;    long actual = gson.fromJson("1", long.class);    assertEquals(expected, actual);    actual = gson.fromJson("1", Long.class);    assertEquals(expected, actual);  }  public void testPrimitiveLongAutoboxedInASingleElementArray() {    long expected = 1L;    long actual = gson.fromJson("[1]", long.class);    assertEquals(expected, actual);    actual = gson.fromJson("[1]", Long.class);    assertEquals(expected, actual);  }  public void testPrimitiveIntegerAutoboxed() {    int expected = 1;    int actual = gson.fromJson("1", int.class);    assertEquals(expected, actual);    actual = gson.fromJson("1", Integer.class);    assertEquals(expected, actual);  }  public void testPrimitiveIntegerAutoboxedInASingleElementArray() {    int expected = 1;    int actual = gson.fromJson("[1]", int.class);    assertEquals(expected, actual);    actual = gson.fromJson("[1]", Integer.class);    assertEquals(expected, actual);  }  public void testPrimitiveBooleanAutoboxed() {    assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class));    assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class));    boolean value = gson.fromJson("false", boolean.class);    assertEquals(false, value);    value = gson.fromJson("true", boolean.class);    assertEquals(true, value);  }  public void testPrimitiveBooleanAutoboxedInASingleElementArray() {    assertEquals(Boolean.FALSE, gson.fromJson("[false]", Boolean.class));    assertEquals(Boolean.TRUE, gson.fromJson("[true]", Boolean.class));    boolean value = gson.fromJson("[false]", boolean.class);    assertEquals(false, value);    value = gson.fromJson("[true]", boolean.class);    assertEquals(true, value);  }  public void testPrimitiveDoubleAutoboxed() {    double actual = gson.fromJson("-122.08858585", double.class);    assertEquals(-122.08858585, actual);    actual = gson.fromJson("122.023900008000", Double.class);    assertEquals(122.023900008, actual);  }  public void testPrimitiveDoubleAutoboxedInASingleElementArray() {    double expected = -122.08;    double actual = gson.fromJson("[-122.08]", double.class);    assertEquals(expected, actual);    actual = gson.fromJson("[-122.08]", Double.class);    assertEquals(expected, actual);  }  public void testBagOfPrimitiveWrappers() {    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);    String jsonString = target.getExpectedJson();    target = gson.fromJson(jsonString, BagOfPrimitiveWrappers.class);    assertEquals(jsonString, target.getExpectedJson());  }  public void testDirectedAcyclicGraph() {    String json = "{\"children\":[{\"children\":[{\"children\":[]}]},{\"children\":[]}]}";    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);    assertNotNull(target);    assertEquals(2, target.children.size());  }  public void testEmptyCollectionInAnObject() {    String json = "{\"children\":[]}";    ContainsReferenceToSelfType target = gson.fromJson(json, ContainsReferenceToSelfType.class);    assertNotNull(target);    assertTrue(target.children.isEmpty());  }  public void testPrimitiveArrayInAnObject() {    String json = "{\"longArray\":[0,1,2,3,4,5,6,7,8,9]}";    PrimitiveArray target = gson.fromJson(json, PrimitiveArray.class);    assertEquals(json, target.getExpectedJson());  }  public void testArrayOfPrimitives() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    int[] target = gson.fromJson(json, int[].class);    int[] expected = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };    MoreAsserts.assertEquals(expected, target);  }  public void testArrayOfStrings() {    String json = "[\"Hello\",\"World\"]";    String[] target = gson.fromJson(json, String[].class);    assertEquals("Hello", target[0]);    assertEquals("World", target[1]);  }  @SuppressWarnings("unchecked")  public void testCollectionOfStrings() {    String json = "[\"Hello\",\"World\"]";    Type collectionType = new TypeToken<Collection<String>>() { }.getType();    Collection<String> target = gson.fromJson(json, collectionType);    assertTrue(target.contains("Hello"));    assertTrue(target.contains("World"));  }  public void testCollectionOfIntegers() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    Type collectionType = new TypeToken<Collection<Integer>>() { }.getType();    Collection<Integer> target = gson.fromJson(json, collectionType);    int[] expected = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};    MoreAsserts.assertEquals(expected, toIntArray(target));  }  @SuppressWarnings("unchecked")  public void testRawCollectionNotAllowed() {    String json = "[0,1,2,3,4,5,6,7,8,9]";    try {    gson.fromJson(json, Collection.class);    fail("Can not deserialize a non-genericized collection.");    } catch (JsonParseException expected) { }    json = "[\"Hello\", \"World\"]";    try {      gson.fromJson(json, Collection.class);      fail("Can not deserialize a non-genericized collection.");    } catch (JsonParseException expected) { }  }  public void testListOfIntegerCollections() throws Exception {    String json = "[[1,2,3],[4,5,6],[7,8,9]]";    Type collectionType = new TypeToken<Collection<Collection<Integer>>>() {}.getType();    List<Collection<Integer>> target = gson.fromJson(json, collectionType);    int[][] expected = new int[3][3];    for (int i = 0; i < 3; ++i) {      int start = (3 * i) + 1;      for (int j = 0; j < 3; ++j) {        expected[i][j] = start + j;      }    }    for (int i = 0; i < 3; i++) {      MoreAsserts.assertEquals(expected[i], toIntArray(target.get(i)));    }  }  @SuppressWarnings("unchecked")  private static int[] toIntArray(Collection collection) {    int[] ints = new int[collection.size()];    int i = 0;    for (Iterator iterator = collection.iterator(); iterator.hasNext(); ++i) {      Object obj = iterator.next();      if (obj instanceof Integer) {        ints[i] = ((Integer)obj).intValue();      } else if (obj instanceof Long) {        ints[i] = ((Long)obj).intValue();      }    }    return ints;  }  public void testClassWithTransientFields() throws Exception {    String json = "{\"longValue\":[1]}";    ClassWithTransientFields target = gson.fromJson(        json, ClassWithTransientFields.class);    assertEquals(json, target.getExpectedJson());  }  public void testTransientFieldsPassedInJsonAreIgnored() throws Exception {    String json = "{\"transientLongValue\":1,\"longValue\":[1]}";    ClassWithTransientFields target = gson.fromJson(        json, ClassWithTransientFields.class);    assertFalse(target.transientLongValue != 1);  }  public void testClassWithNoFields() {    String json = "{}";    ClassWithNoFields target = gson.fromJson(json, ClassWithNoFields.class);    assertNotNull(target);  }  public void testTopLevelCollections() {    Type type = new TypeToken<Collection<Integer>>() {    }.getType();    Collection<Integer> collection = gson.fromJson("[1,2,3,4,5,6,7,8,9]", type);    assertEquals(9, collection.size());  }  public void testTopLevelArray() {    int[] expected = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };    int[] actual = gson.fromJson("[1,2,3,4,5,6,7,8,9]", int[].class);    MoreAsserts.assertEquals(expected, actual);  }  public void testEmptyArray() {    int[] actualObject = gson.fromJson("[]", int[].class);    assertTrue(actualObject.length == 0);    Integer[] actualObject2 = gson.fromJson("[]", Integer[].class);    assertTrue(actualObject2.length == 0);  }  public void testNested() {    String json = "{\"primitive1\":{\"longValue\":10,\"intValue\":20,\"booleanValue\":false,"        + "\"stringValue\":\"stringValue\"},\"primitive2\":{\"longValue\":30,\"intValue\":40,"        + "\"booleanValue\":true,\"stringValue\":\"stringValue\"}}";    Nested target = gson.fromJson(json, Nested.class);    assertEquals(json, target.getExpectedJson());  }  public void testInheritence() {    String json = "{\"value\":5,\"primitive1\":{\"longValue\":10,\"intValue\":20,"        + "\"booleanValue\":false,\"stringValue\":\"stringValue\"},\"primitive2\":"        + "{\"longValue\":30,\"intValue\":40,\"booleanValue\":true,"        + "\"stringValue\":\"stringValue\"}}";    SubTypeOfNested target = gson.fromJson(json, SubTypeOfNested.class);    assertEquals(json, target.getExpectedJson());  }  public void testNull() {    try {      gson.fromJson("", Object.class);      fail("Null strings should not be allowed");    } catch (JsonParseException expected) {    }  }  public void testNullFields() {    String json = "{\"primitive1\":{\"longValue\":10,\"intValue\":20,\"booleanValue\":false"        + ",\"stringValue\":\"stringValue\"}}";    Nested target = gson.fromJson(json, Nested.class);    assertEquals(json, target.getExpectedJson());  }  public void testSubInterfacesOfCollection() {    String json = "{\"list\":[0,1,2,3],\"queue\":[0,1,2,3],\"set\":[0.1,0.2,0.3,0.4],"        + "\"sortedSet\":[\"a\",\"b\",\"c\",\"d\"]"//        + ",\"navigableSet\":[\"abc\",\"def\",\"ghi\",\"jkl\"]"        + "}";    ClassWithSubInterfacesOfCollection target = gson.fromJson(        json, ClassWithSubInterfacesOfCollection.class);    assertEquals(json, target.getExpectedJson());  }  public void testCustomDeserializer() {    gson.registerDeserializer(ClassWithCustomTypeConverter.class,        new JsonDeserializer<ClassWithCustomTypeConverter>() {      public ClassWithCustomTypeConverter deserialize(JsonElement json, Type typeOfT,          JsonDeserializationContext context) {        JsonObject jsonObject = json.getAsJsonObject();        int value = jsonObject.get("bag").getAsInt();        return new ClassWithCustomTypeConverter(new BagOfPrimitives(value,            value, false, ""), value);      }    });    String json = "{\"bag\":5,\"value\":25}";    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);    assertEquals(5, target.getBag().getIntValue());  }  public void testNestedCustomTypeConverters() {    gson.registerDeserializer(BagOfPrimitives.class, new JsonDeserializer<BagOfPrimitives>() {      public BagOfPrimitives deserialize(JsonElement json, Type typeOfT,          JsonDeserializationContext context) throws JsonParseException {        int value = json.getAsInt();        return new BagOfPrimitives(value, value, false, "");      }    });    String json = "{\"bag\":7,\"value\":25}";    ClassWithCustomTypeConverter target = gson.fromJson(json, ClassWithCustomTypeConverter.class);    assertEquals(7, target.getBag().getIntValue());  }  public void testArrayOfObjects() {    String json = new ArrayOfObjects().getExpectedJson();    ArrayOfObjects target = gson.fromJson(json, ArrayOfObjects.class);    assertEquals(json, target.getExpectedJson());  }  public void testArrayOfArrays() {    String json = new ArrayOfArrays().getExpectedJson();    ArrayOfArrays target = gson.fromJson(json, ArrayOfArrays.class);    assertEquals(json, target.getExpectedJson());  }  private static class MyParameterizedDeserializer<T>      implements JsonDeserializer<MyParameterizedType<T>> {    @SuppressWarnings("unchecked")    public MyParameterizedType<T> deserialize(JsonElement json, Type typeOfT,        JsonDeserializationContext context) throws JsonParseException {      Type genericClass = new TypeInfo<Object>(typeOfT).getGenericClass();      String className = new TypeInfo<Object>(genericClass).getTopLevelClass().getSimpleName();      T value = (T) json.getAsJsonObject().get(className).getAsObject();      return new MyParameterizedType<T>(value);    }  }  private static class MyParameterizedTypeInstanceCreator<T>      implements InstanceCreator<MyParameterizedType<T>> {    private final T defaultValue;    MyParameterizedTypeInstanceCreator(T defaultValue) {      this.defaultValue = defaultValue;    }    public MyParameterizedType<T> createInstance(Type type) {      return new MyParameterizedType<T>(defaultValue);    }  }  public void testParameterizedTypesWithCustomDeserializer() {    Type ptIntegerType = new TypeToken<MyParameterizedType<Long>>() {}.getType();    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();    gson.registerDeserializer(ptIntegerType, new MyParameterizedDeserializer<Long>());    gson.registerDeserializer(ptStringType, new MyParameterizedDeserializer<String>());    gson.registerInstanceCreator(ptIntegerType,        new MyParameterizedTypeInstanceCreator<Long>(new Long(0)));    gson.registerInstanceCreator(ptStringType,        new MyParameterizedTypeInstanceCreator<String>(""));    String json = new MyParameterizedType<Long>(new Long(10)).getExpectedJson();    MyParameterizedType<Long> intTarget = gson.fromJson(json, ptIntegerType);    assertEquals(json, intTarget.getExpectedJson());    json = new MyParameterizedType<String>("abc").getExpectedJson();    MyParameterizedType<String> stringTarget = gson.fromJson(json, ptStringType);    assertEquals(json, stringTarget.getExpectedJson());  }  public void testTopLevelEnum() {    gson.registerInstanceCreator(MyEnum.class, new MyEnumCreator());    String json = MyEnum.VALUE1.getExpectedJson();    MyEnum target = gson.fromJson(json, MyEnum.class);    assertEquals(json, target.getExpectedJson());  }  public void testTopLevelEnumInASingleElementArray() {    gson.registerInstanceCreator(MyEnum.class, new MyEnumCreator());    String json = "[" + MyEnum.VALUE1.getExpectedJson() + "]";    MyEnum target = gson.fromJson(json, MyEnum.class);    assertEquals(json, "[" + target.getExpectedJson() + "]");  }  public void testClassWithEnumField() {    gson.registerInstanceCreator(MyEnum.class, new MyEnumCreator());    String json = new ClassWithEnumFields().getExpectedJson();    ClassWithEnumFields target = gson.fromJson(json, ClassWithEnumFields.class);    assertEquals(json, target.getExpectedJson());  }  public void testCollectionOfEnums() {    gson.registerInstanceCreator(MyEnum.class, new MyEnumCreator());    Type type = new TypeToken<Collection<MyEnum>>() {    }.getType();    String json = "[\"VALUE1\",\"VALUE2\"]";    Collection<MyEnum> target = gson.fromJson(json, type);    MoreAsserts.assertContains(target, MyEnum.VALUE1);    MoreAsserts.assertContains(target, MyEnum.VALUE2);  }  public void testPrivateNoArgConstructor() {    ClassWithPrivateNoArgsConstructor target =      gson.fromJson("{\"a\":20}", ClassWithPrivateNoArgsConstructor.class);    assertEquals(20, target.a);  }  public void testDefaultSupportForUrl() throws Exception {    String urlValue = "http://google.com/";    String json = '"' + urlValue + '"';    URL target = gson.fromJson(json, URL.class);    assertEquals(urlValue, target.toExternalForm());  }  public void testDefaultSupportForUri() throws Exception {    String uriValue = "http://google.com/";    String json = '"' + uriValue + '"';    URI target = gson.fromJson(json, URI.class);    assertEquals(uriValue, target.toASCIIString());  }  public void testDefaultSupportForLocaleWithLanguage() throws Exception {    String json = "\"en\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals("en", locale.getLanguage());      }  public void testDefaultSupportForLocaleWithLanguageCountry() throws Exception {    String json = "\"fr_CA\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals(Locale.CANADA_FRENCH, locale);      }  public void testDefaultSupportForLocaleWithLanguageCountryVariant() throws Exception {    String json = "\"de_DE_EURO\"";    Locale locale = gson.fromJson(json, Locale.class);    assertEquals("de", locale.getLanguage());        assertEquals("DE", locale.getCountry());        assertEquals("EURO", locale.getVariant());      }  public void testMap() throws Exception {    String json = "{\"a\":1,\"b\":2}";    Type typeOfMap = new TypeToken<Map<String,Integer>>(){}.getType();    Map<String, Integer> target = gson.fromJson(json, typeOfMap);    assertEquals(1, target.get("a").intValue());    assertEquals(2, target.get("b").intValue());  }    public void testExposeAnnotation() {    String json = '{' + "\"a\":" + 3 + ",\"b\":" + 4 + '}';    // First test that Gson works without the expose annotation as well    ClassWithExposedFields target = gson.fromJson(json, ClassWithExposedFields.class);    assertEquals(3, target.a);    assertEquals(4, target.b);    // Now recreate gson with the proper setting    gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();    target = gson.fromJson(json, ClassWithExposedFields.class);    assertEquals(3, target.a);    assertEquals(2, target.b);  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.ParameterizedTypeHandlerMap;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Unit tests for the {@link ParameterizedTypeHandlerMap} class. * * @author Joel Leitch */public class ParameterizedTypeHandlerMapTest extends TestCase {  private ParameterizedTypeHandlerMap<String> paramMap;  @Override  protected void setUp() throws Exception {    super.setUp();    paramMap = new ParameterizedTypeHandlerMap<String>();  }  public void testNullMap() throws Exception {    assertFalse(paramMap.hasSpecificHandlerFor(String.class));    assertFalse(paramMap.hasAnyHandlerFor(String.class));    assertNull(paramMap.getHandlerFor(String.class));  }  public void testHasGenericButNotSpecific() throws Exception {    Type specificType = new TypeToken<List<String>>() {}.getType();    String handler = "blah";    paramMap.register(List.class, handler);    assertFalse(paramMap.hasSpecificHandlerFor(specificType));    assertTrue(paramMap.hasSpecificHandlerFor(List.class));    assertTrue(paramMap.hasAnyHandlerFor(specificType));    assertTrue(paramMap.hasAnyHandlerFor(List.class));    assertEquals(handler, paramMap.getHandlerFor(specificType));  }  public void testHasSpecificType() throws Exception {    Type specificType = new TypeToken<List<String>>() {}.getType();    String handler = "blah";    paramMap.register(specificType, handler);    assertTrue(paramMap.hasSpecificHandlerFor(specificType));    assertFalse(paramMap.hasSpecificHandlerFor(List.class));    assertTrue(paramMap.hasAnyHandlerFor(specificType));    assertFalse(paramMap.hasAnyHandlerFor(List.class));    assertEquals(handler, paramMap.getHandlerFor(specificType));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.List;/** * Exercising the construction of the Parameter object and ensure the * proper types are returned. * * @author Joel Leitch */public class TypeInfoTest extends TestCase {  public void testPrimitiveArray() throws Exception {    TypeInfo<int[]> arrayTypeInfo = new TypeInfo<int[]>(int[].class);    assertTrue(arrayTypeInfo.isArray());    assertEquals(int.class, arrayTypeInfo.getSecondLevelClass());    assertFalse(arrayTypeInfo.isPrimitiveOrStringAndNotAnArray());  }  public void testObjectArray() throws Exception {    TypeInfo<String[]> arrayTypeInfo = new TypeInfo<String[]>(String[].class);    assertTrue(arrayTypeInfo.isArray());    assertEquals(String.class, arrayTypeInfo.getSecondLevelClass());    assertEquals(String[].class, arrayTypeInfo.getTopLevelClass());  }  @SuppressWarnings("unchecked")  public void testPrimitive() throws Exception {    TypeInfo typeInfo = new TypeInfo(boolean.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isString());    assertTrue(typeInfo.isPrimitive());    assertEquals(boolean.class, typeInfo.getSecondLevelClass());    assertEquals(Boolean.class, typeInfo.getWrappedClazz());  }  public void testPrimitiveWrapper() throws Exception {    TypeInfo<Integer> typeInfo = new TypeInfo<Integer>(Integer.class);    assertEquals(Integer.class, typeInfo.getSecondLevelClass());    assertTrue(typeInfo.isPrimitive());    assertTrue(typeInfo.isPrimitiveOrStringAndNotAnArray());  }  public void testString() throws Exception {    TypeInfo<String> typeInfo = new TypeInfo<String>(String.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(String.class, typeInfo.getSecondLevelClass());    assertTrue(typeInfo.isPrimitiveOrStringAndNotAnArray());  }  public void testObject() throws Exception {    TypeInfo<Object> typeInfo = new TypeInfo<Object>(Object.class);    assertFalse(typeInfo.isArray());    assertFalse(typeInfo.isPrimitive());    assertEquals(Object.class, typeInfo.getSecondLevelClass());    assertFalse(typeInfo.isPrimitiveOrStringAndNotAnArray());  }  @SuppressWarnings("unchecked")  public void testPrimitiveType() throws Exception {    TypeInfo typeInfo = new TypeInfo(long[].class);    assertTrue(typeInfo.isArray());    assertEquals(long.class, typeInfo.getSecondLevelClass());    typeInfo = new TypeInfo(long.class);    assertFalse(typeInfo.isArray());    assertEquals(long.class, typeInfo.getSecondLevelClass());  }  @SuppressWarnings("unchecked")  public void testObjectType() throws Exception {    TypeInfo typeInfo = new TypeInfo(String.class);    assertFalse(typeInfo.isArray());    assertTrue(typeInfo.isString());    assertEquals(String.class, typeInfo.getSecondLevelClass());    typeInfo = new TypeInfo(String[].class);    assertTrue(typeInfo.isArray());    assertEquals(String.class, typeInfo.getSecondLevelClass());  }  @SuppressWarnings("unchecked")  public void testParameterizedTypes() throws Exception {    Type type = new TypeToken<List<String>>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertFalse(typeInfo.isArray());    assertEquals(List.class, typeInfo.getSecondLevelClass());  }  @SuppressWarnings("unchecked")  public void testArrayAsParameterizedTypes() throws Exception {    Type type = new TypeToken<List<String>[]>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertTrue(typeInfo.isArray());    assertEquals(List.class, typeInfo.getSecondLevelClass());    assertEquals(String.class, typeInfo.getGenericClass());  }  @SuppressWarnings("unchecked")  public void testGenericizedGenericType() throws Exception {    Type type = new TypeToken<List<List<String>>>() {}.getType();    Type genericType = new TypeToken<List<String>>() {}.getType();    TypeInfo typeInfo = new TypeInfo(type);    assertFalse(typeInfo.isArray());    assertEquals(List.class, typeInfo.getSecondLevelClass());    assertEquals(genericType, typeInfo.getGenericClass());    typeInfo = new TypeInfo(genericType);    assertEquals(String.class, typeInfo.getGenericClass());  }  @SuppressWarnings("unchecked")  public void testStrangeTypeParameters() throws Exception {    try {      new TypeInfo(new Type() {});      fail("Should not be able to determine this unknown type");    } catch (IllegalArgumentException expected) {    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.TestTypes.ArrayOfArrays;import com.google.gson.TestTypes.ArrayOfObjects;import com.google.gson.TestTypes.BagOfPrimitiveWrappers;import com.google.gson.TestTypes.BagOfPrimitives;import com.google.gson.TestTypes.ClassOverridingEquals;import com.google.gson.TestTypes.ClassWithCustomTypeConverter;import com.google.gson.TestTypes.ClassWithEnumFields;import com.google.gson.TestTypes.ClassWithExposedFields;import com.google.gson.TestTypes.ClassWithNoFields;import com.google.gson.TestTypes.ClassWithSubInterfacesOfCollection;import com.google.gson.TestTypes.ClassWithTransientFields;import com.google.gson.TestTypes.ContainsReferenceToSelfType;import com.google.gson.TestTypes.MyEnum;import com.google.gson.TestTypes.MyParameterizedType;import com.google.gson.TestTypes.Nested;import com.google.gson.TestTypes.PrimitiveArray;import com.google.gson.TestTypes.SubTypeOfNested;import com.google.gson.annotations.Since;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Modifier;import java.lang.reflect.Type;import java.net.URI;import java.net.URL;import java.util.ArrayList;import java.util.Arrays;import java.util.Collection;import java.util.LinkedHashMap;import java.util.LinkedList;import java.util.List;import java.util.Locale;import java.util.Map;import java.util.Queue;import java.util.Set;import java.util.SortedSet;import java.util.TreeSet;/** * Small test for Json Serialization * * @author Inderjeet Singh * @author Joel Leitch */public class JsonSerializerTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    gson = new Gson();  }  public void testCircular() {    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();    a.children.add(b);    b.children.add(a);    try {      gson.toJson(a);      fail("Circular types should not get printed!");    } catch (IllegalStateException expected) { }  }  public void testSelfReference() throws Exception {    ClassOverridingEquals objA = new ClassOverridingEquals();    objA.ref = objA;    try {      gson.toJson(objA);      fail("Circular reference to self can not be serialized!");    } catch (IllegalStateException expected) { }  }  public void testObjectEqualButNotSame() throws Exception {    ClassOverridingEquals objA = new ClassOverridingEquals();    ClassOverridingEquals objB = new ClassOverridingEquals();    objB.ref = objA;    assertEquals(objB.getExpectedJson(), gson.toJson(objB));  }  public void testDirectedAcyclicGraph() {    ContainsReferenceToSelfType a = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType b = new ContainsReferenceToSelfType();    ContainsReferenceToSelfType c = new ContainsReferenceToSelfType();    a.children.add(b);    a.children.add(c);    b.children.add(c);    assertNotNull(gson.toJson(a));  }  public void testClassWithTransientFields() throws Exception {    ClassWithTransientFields target = new ClassWithTransientFields(1L);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testClassWithNoFields() {    assertEquals("{}", gson.toJson(new ClassWithNoFields()));  }  public void testAnonymousLocalClasses() {    assertEquals("", gson.toJson(new ClassWithNoFields() {      // empty anonymous class    }));    gson = new Gson(new ObjectNavigatorFactory(new ModifierBasedExclusionStrategy(        true, Modifier.TRANSIENT, Modifier.STATIC)));    assertEquals("{}", gson.toJson(new ClassWithNoFields() {      // empty anonymous class    }));  }  public void testStringValue() throws Exception {    String value = "someRandomStringValue";    assertEquals('"' + value + '"', gson.toJson(value));  }  public void testPrimitiveIntegerAutoboxed() {    assertEquals("1", gson.toJson(1));  }  public void testPrimitiveBooleanAutoboxed() {    assertEquals("true", gson.toJson(true));    assertEquals("false", gson.toJson(false));  }  public void testPrimitiveDoubleAutoboxed() {    assertEquals("-122.08234335", gson.toJson(-122.08234335));    assertEquals("122.08112002", gson.toJson(new Double(122.08112002)));  }  public void testArrayOfOneValue() {    int target[] = {1};    assertEquals("[1]", gson.toJson(target));  }  public void testBagOfPrimitives() {    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testBagOfPrimitiveWrappers() {    BagOfPrimitiveWrappers target = new BagOfPrimitiveWrappers(10L, 20, false);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testPrimitiveArrayField() throws Exception {    PrimitiveArray target = new PrimitiveArray(new long[] { 1L, 2L, 3L });    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testCollection() {    Collection<Integer> target = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));  }  public void testEmptyArray() {    int[] target = {};    assertEquals("[]", gson.toJson(target));  }  public void testEmptyCollectionInAnObject() {    ContainsReferenceToSelfType target = new ContainsReferenceToSelfType();    assertEquals("{\"children\":[]}", gson.toJson(target));  }  public void testArrayOfInts() {    int[] target = {1, 2, 3, 4, 5, 6, 7, 8, 9};    assertEquals("[1,2,3,4,5,6,7,8,9]", gson.toJson(target));  }  public void testArrayOfObjects() {    ArrayOfObjects target = new ArrayOfObjects();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testArrayOfStrings() {    String[] target = {"Hello", "World"};    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));  }  public void testArrayOfArrays() {    ArrayOfArrays target = new ArrayOfArrays();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testCollectionOfStrings() {    List<String> target = new ArrayList<String>();    target.add("Hello");    target.add("World");    assertEquals("[\"Hello\",\"World\"]", gson.toJson(target));  }  public void testCollectionOfObjects() {    List<BagOfPrimitives> target = new ArrayList<BagOfPrimitives>();    BagOfPrimitives objA = new BagOfPrimitives(3L, 1, true, "blah");    BagOfPrimitives objB = new BagOfPrimitives(2L, 6, false, "blahB");    target.add(objA);    target.add(objB);    String result = gson.toJson(target);    assertTrue(result.startsWith("["));    assertTrue(result.endsWith("]"));    for (BagOfPrimitives obj : target) {      assertTrue(result.contains(obj.getExpectedJson()));    }  }  public void testNested() {    Nested target = new Nested(new BagOfPrimitives(10, 20, false, "stringValue"),       new BagOfPrimitives(30, 40, true, "stringValue"));    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testInheritence() {    SubTypeOfNested target = new SubTypeOfNested(new BagOfPrimitives(10, 20, false, "stringValue"),        new BagOfPrimitives(30, 40, true, "stringValue"));    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testNull() {    assertEquals("", gson.toJson(null));  }  public void testNullFields() {    Nested target = new Nested(new BagOfPrimitives(10, 20, false, "stringValue"), null);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testSubInterfacesOfCollection() {    List<Integer> list = new LinkedList<Integer>();    list.add(0);    list.add(1);    list.add(2);    list.add(3);    Queue<Long> queue = new LinkedList<Long>();    queue.add(0L);    queue.add(1L);    queue.add(2L);    queue.add(3L);    Set<Float> set = new TreeSet<Float>();    set.add(0.1F);    set.add(0.2F);    set.add(0.3F);    set.add(0.4F);    SortedSet<Character> sortedSet = new TreeSet<Character>();    sortedSet.add('a');    sortedSet.add('b');    sortedSet.add('c');    sortedSet.add('d');//    NavigableSet<String> navigableSet = Sets.newTreeSet("abc", "def", "ghi", "jkl");    ClassWithSubInterfacesOfCollection target =        new ClassWithSubInterfacesOfCollection(list, queue, set, sortedSet/*, navigableSet */);    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testCustomSerializers() {    gson.registerSerializer(ClassWithCustomTypeConverter.class,        new JsonSerializer<ClassWithCustomTypeConverter>() {      public JsonElement serialize(ClassWithCustomTypeConverter src, Type typeOfSrc,          JsonSerializationContext context) {        JsonObject json = new JsonObject();        json.addProperty("bag", 5);        json.addProperty("value", 25);        return json;      }    });    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();    assertEquals("{\"bag\":5,\"value\":25}", gson.toJson(target));  }  public void testNestedCustomSerializers() {    gson.registerSerializer(BagOfPrimitives.class, new JsonSerializer<BagOfPrimitives>() {      public JsonElement serialize(BagOfPrimitives src, Type typeOfSrc,          JsonSerializationContext context) {        return new JsonPrimitive(6);      }    });    ClassWithCustomTypeConverter target = new ClassWithCustomTypeConverter();    assertEquals("{\"bag\":6,\"value\":10}", gson.toJson(target));  }  public void testStaticFieldsAreNotSerialized() {    BagOfPrimitives target = new BagOfPrimitives();    assertFalse(gson.toJson(target).contains("DEFAULT_VALUE"));  }  private static class MyParameterizedSerializer<T>      implements JsonSerializer<MyParameterizedType<T>> {    public JsonElement serialize(MyParameterizedType<T> src, Type classOfSrc,        JsonSerializationContext context) {      JsonObject json = new JsonObject();      T value = src.getValue();      json.add(value.getClass().getSimpleName(), context.serialize(value));      return json;    }  }  public void testParameterizedTypeWithCustomSerializer() {    Type ptIntegerType = new TypeToken<MyParameterizedType<Integer>>() {}.getType();    Type ptStringType = new TypeToken<MyParameterizedType<String>>() {}.getType();    gson.registerSerializer(ptIntegerType, new MyParameterizedSerializer<Integer>());    gson.registerSerializer(ptStringType, new MyParameterizedSerializer<String>());    MyParameterizedType<Integer> intTarget = new MyParameterizedType<Integer>(10);    assertEquals(intTarget.getExpectedJson(), gson.toJson(intTarget, ptIntegerType));    MyParameterizedType<String> stringTarget = new MyParameterizedType<String>("abc");    assertEquals(stringTarget.getExpectedJson(), gson.toJson(stringTarget, ptStringType));  }  public void testTopLevelEnum() {    MyEnum target = MyEnum.VALUE1;    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testClassWithEnumField() {    ClassWithEnumFields target = new ClassWithEnumFields();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  static class Version1 {    int a = 0;    @Since(1.0) int b = 1;  }  static class Version1_1 extends Version1 {    @Since(1.1) int c = 2;  }  @Since(1.2)  static class Version1_2 {    int d = 3;  }  public void testVersionedClasses() {    Gson gson = new GsonBuilder().setVersion(1.0).create();    String json1 = gson.toJson(new Version1());    String json2 = gson.toJson(new Version1_1());    assertEquals(json1, json2);  }  public void testIgnoreLaterVersionClass() {    Gson gson = new GsonBuilder().setVersion(1.0).create();    assertEquals("", gson.toJson(new Version1_2()));  }  public void testVersionedGsonWithUnversionedClasses() {    Gson gson = new GsonBuilder().setVersion(1.0).create();    BagOfPrimitives target = new BagOfPrimitives(10, 20, false, "stringValue");    assertEquals(target.getExpectedJson(), gson.toJson(target));  }  public void testDefaultSupportForUrl() throws Exception {    String urlValue = "http://google.com/";    URL url = new URL(urlValue);    assertEquals('"' + urlValue + '"', gson.toJson(url));  }  public void testDefaultSupportForUri() throws Exception {    String uriValue = "http://google.com/";    URI uri = new URI(uriValue);    assertEquals('"' + uriValue + '"', gson.toJson(uri));  }  public void testDefaultSupportForLocaleWithLanguage() throws Exception {    Locale target = new Locale("en");    assertEquals("\"en\"", gson.toJson(target));  }  public void testDefaultSupportForLocaleWithLanguageCountry() throws Exception {    Locale target = Locale.CANADA_FRENCH;    assertEquals("\"fr_CA\"", gson.toJson(target));  }  public void testDefaultSupportForLocaleWithLanguageCountryVariant() throws Exception {    Locale target = new Locale("de", "DE", "EURO");    String json = gson.toJson(target);    assertEquals("\"de_DE_EURO\"", json);  }  public void testMap() throws Exception {    Map<String, Integer> map = new LinkedHashMap<String, Integer>();    map.put("a", 1);    map.put("b", 2);    Type typeOfMap = new TypeToken<Map<String, Integer>>() {}.getType();    String json = gson.toJson(map, typeOfMap);    assertTrue(json.contains("\"a\":1"));    assertTrue(json.contains("\"b\":2"));  }    public void testExposeAnnotation() {    // First test that Gson works without the expose annotation as well    ClassWithExposedFields target = new ClassWithExposedFields();    assertEquals(target.getExpectedJsonWithoutAnnotations(), gson.toJson(target));    // Now recreate gson with the proper setting    gson = new GsonBuilder().excludeFieldsWithoutExposeAnnotation().create();    assertEquals(target.getExpectedJson(), gson.toJson(target));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.DisjunctionExclusionStrategy;import com.google.gson.ExclusionStrategy;import junit.framework.TestCase;import java.lang.reflect.Field;import java.util.LinkedList;import java.util.List;/** * Unit tests for the {@link DisjunctionExclusionStrategy} class. * * @author Joel Leitch */public class DisjunctionExclusionStrategyTest extends TestCase {  private static final ExclusionStrategy FALSE_STRATEGY = new MockExclusionStrategy(false, false);  private static final ExclusionStrategy TRUE_STRATEGY = new MockExclusionStrategy(true, true);  private static final Class<?> CLAZZ = String.class;  private static final Field FIELD = CLAZZ.getFields()[0];  public void testBadInstantiation() throws Exception {    try {      new DisjunctionExclusionStrategy();    } catch (IllegalArgumentException expected) { }    try {      ExclusionStrategy[] constructorParam = null;      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }    try {      ExclusionStrategy[] constructorParam = new ExclusionStrategy[0];      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }    try {      List<ExclusionStrategy> constructorParam = null;      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }    try {      List<ExclusionStrategy> constructorParam = new LinkedList<ExclusionStrategy>();      new DisjunctionExclusionStrategy(constructorParam);    } catch (IllegalArgumentException expected) { }  }  public void testSkipFieldsWithMixedTrueAndFalse() throws Exception {    DisjunctionExclusionStrategy strategy =        new DisjunctionExclusionStrategy(FALSE_STRATEGY, TRUE_STRATEGY);    assertTrue(strategy.shouldSkipClass(CLAZZ));    assertTrue(strategy.shouldSkipField(FIELD));  }  public void testSkipFieldsWithFalseOnly() throws Exception {    DisjunctionExclusionStrategy strategy =  new DisjunctionExclusionStrategy(FALSE_STRATEGY);    assertFalse(strategy.shouldSkipClass(CLAZZ));    assertFalse(strategy.shouldSkipField(FIELD));  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.TestTypes.ArrayOfObjects;import com.google.gson.TestTypes.BagOfPrimitives;import com.google.gson.reflect.TypeToken;import junit.framework.TestCase;import java.lang.reflect.Type;import java.util.LinkedList;import java.util.List;/** * Small test for {@link JsonPrintFormatter} *  * @author Inderjeet Singh */public class JsonPrintFormatterTest extends TestCase {  private static int INDENTATION_SIZE = 2;  private static int PRINT_MARGIN = 100;  private static int RIGHT_MARGIN = 8;  private static boolean DEBUG = false;  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    JsonFormatter formatter = new JsonPrintFormatter(PRINT_MARGIN, INDENTATION_SIZE, RIGHT_MARGIN);    gson = new GsonBuilder().setFormatter(formatter).create();  }  public void testList() {    BagOfPrimitives b = new BagOfPrimitives();    List<BagOfPrimitives> listOfB = new LinkedList<BagOfPrimitives>();    for (int i = 0; i < 15; ++i) {      listOfB.add(b);    }    Type typeOfSrc = new TypeToken<List<BagOfPrimitives>>() {}.getType();    String json = gson.toJson(listOfB, typeOfSrc);    print(json);    assertPrintMargin(json);  }  public void testArrayOfObjects() {    ArrayOfObjects target = new ArrayOfObjects();    String json = gson.toJson(target);    print(json);    assertPrintMargin(json);  }  private void print(String msg) {    if (DEBUG) {      System.out.println(msg);    }  }  private void assertPrintMargin(String str) {    int position = 0;    char[] chars = str.toCharArray();    for (int i = 0; i < chars.length; ++i, ++position) {      char c = chars[i];      if (c == '\n') {        position = 0;      }      assertTrue(position < PRINT_MARGIN + RIGHT_MARGIN);    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import java.lang.reflect.Type;import java.util.ArrayList;import java.util.Collection;import java.util.List;import java.util.Queue;import java.util.Set;import java.util.SortedSet;import com.google.gson.InstanceCreator;import com.google.gson.Primitives;import com.google.gson.annotations.Expose;/** * Types used for testing JSON serialization and deserialization * * @author Inderjeet Singh * @author Joel Leitch */public class TestTypes {  public static class BagOfPrimitives {    private static final long DEFAULT_VALUE = 0;    private final long longValue;    private final int intValue;    private final boolean booleanValue;    private final String stringValue;    public BagOfPrimitives() {      this(DEFAULT_VALUE, 0, false, "");    }    public BagOfPrimitives(long longValue, int intValue, boolean booleanValue, String stringValue) {      this.longValue = longValue;      this.intValue = intValue;      this.booleanValue = booleanValue;      this.stringValue = stringValue;    }    public int getIntValue() {      return intValue;    }        public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":").append(longValue).append(",");      sb.append("\"intValue\":").append(intValue).append(",");      sb.append("\"booleanValue\":").append(booleanValue).append(",");      sb.append("\"stringValue\":\"").append(stringValue).append("\"");      sb.append("}");      return sb.toString();    }  }  public static class BagOfPrimitiveWrappers {    private final Long longValue;    private final Integer intValue;    private final Boolean booleanValue;    public BagOfPrimitiveWrappers() {      this(0L, 0, false);    }    public BagOfPrimitiveWrappers(Long longValue, Integer intValue, Boolean booleanValue) {      this.longValue = longValue;      this.intValue = intValue;      this.booleanValue = booleanValue;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":").append(longValue).append(",");      sb.append("\"intValue\":").append(intValue).append(",");      sb.append("\"booleanValue\":").append(booleanValue);      sb.append("}");      return sb.toString();    }  }  public static class PrimitiveArray {    private final long[] longArray;    public PrimitiveArray() {      this(new long[0]);    }    public PrimitiveArray(long[] longArray) {      this.longArray = longArray;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{\"longArray\":[");      boolean first = true;      for (long l : longArray) {        if (!first) {          sb.append(",");        } else {          first = false;        }        sb.append(l);      }      sb.append("]}");      return sb.toString();    }  }  public static class Nested {    private final BagOfPrimitives primitive1;    private final BagOfPrimitives primitive2;    public Nested() {      this(null, null);    }    public Nested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {      this.primitive1 = primitive1;      this.primitive2 = primitive2;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      appendFields(sb);      sb.append("}");      return sb.toString();    }    public void appendFields(StringBuilder sb) {      if (primitive1 != null) {        sb.append("\"primitive1\":").append(primitive1.getExpectedJson());      }      if (primitive1 != null && primitive2 != null) {        sb.append(",");      }      if (primitive2 != null) {        sb.append("\"primitive2\":").append(primitive2.getExpectedJson());      }    }  }  public static class ClassWithTransientFields {    public final transient long transientLongValue;    private final long[] longValue;    public ClassWithTransientFields() {      this(0L);    }    public ClassWithTransientFields(long value) {      longValue = new long[] { value };      transientLongValue = value + 1;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"longValue\":[").append(longValue[0]).append("]");      sb.append("}");      return sb.toString();    }  }  public static class ClassWithNoFields {    // Nothing here.. .  }  public static class ClassWithSubInterfacesOfCollection {    private List<Integer> list;    private Queue<Long> queue;    private Set<Float> set;    private SortedSet<Character> sortedSet;//    private NavigableSet<String> navigableSet;    ClassWithSubInterfacesOfCollection() {    }    public ClassWithSubInterfacesOfCollection(List<Integer> list, Queue<Long> queue, Set<Float> set,        SortedSet<Character> sortedSet /* NavigableSet<String> navigableSet*/) {      this.list = list;      this.queue = queue;      this.set = set;      this.sortedSet = sortedSet;//      this.navigableSet = navigableSet;    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder();      sb.append("{");      sb.append("\"list\":");      append(sb, list).append(",");      sb.append("\"queue\":");      append(sb, queue).append(",");      sb.append("\"set\":");      append(sb, set).append(",");      sb.append("\"sortedSet\":");      append(sb, sortedSet);/*      sb.append(",");      sb.append("\"navigableSet\":");      append(sb, navigableSet); */      sb.append("}");      return sb.toString();    }    private StringBuilder append(StringBuilder sb, Collection<?> c) {      sb.append("[");      boolean first = true;      for (Object o : c) {        if (!first) {          sb.append(",");        } else {          first = false;        }        if (o instanceof String || o instanceof Character) {          sb.append('\"');        }        sb.append(o.toString());        if (o instanceof String || o instanceof Character) {          sb.append('\"');        }      }      sb.append("]");      return sb;    }  }  public static class ContainsReferenceToSelfType {    public Collection<ContainsReferenceToSelfType> children =         new ArrayList<ContainsReferenceToSelfType>();  }  public static class SubTypeOfNested extends Nested {    private long value = 5;    public SubTypeOfNested() {      this(null, null);    }    public SubTypeOfNested(BagOfPrimitives primitive1, BagOfPrimitives primitive2) {      super(primitive1, primitive2);    }    @Override    public void appendFields(StringBuilder sb) {      sb.append("\"value\":").append(value).append(",");      super.appendFields(sb);    }  }  public static class ClassWithCustomTypeConverter {    private final BagOfPrimitives bag;    private final int value;    public ClassWithCustomTypeConverter() {      this(new BagOfPrimitives(), 10);    }    public ClassWithCustomTypeConverter(int value) {      this(new BagOfPrimitives(value, value, false, ""), value);    }        public ClassWithCustomTypeConverter(BagOfPrimitives bag, int value) {      this.bag = bag;      this.value = value;    }    public BagOfPrimitives getBag() {      return bag;    }        public String getExpectedJson() {      return "{\"url\":\"" + bag.getExpectedJson() + "\",\"value\":" + value + "}";    }    public int getValue() {      return value;    }  }  public static class ArrayOfObjects {    private final BagOfPrimitives[] elements;    public ArrayOfObjects() {      elements = new BagOfPrimitives[3];      for (int i = 0; i < elements.length; ++i) {        elements[i] = new BagOfPrimitives(i, i+2, false, "i"+i);      }    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{\"elements\":[");      boolean first = true;      for (BagOfPrimitives element : elements) {        if (first) {          first = false;        } else {          sb.append(",");        }        sb.append(element.getExpectedJson());      }      sb.append("]}");      return sb.toString();    }  }  public static class ArrayOfArrays {    private final BagOfPrimitives[][] elements;    public ArrayOfArrays() {      elements = new BagOfPrimitives[3][2];      for (int i = 0; i < elements.length; ++i) {        BagOfPrimitives[] row = elements[i];        for (int j = 0; j < row.length; ++j) {          row[j] = new BagOfPrimitives(i+j, i*j, false, i+"_"+j);        }      }    }    public String getExpectedJson() {      StringBuilder sb = new StringBuilder("{\"elements\":[");      boolean first = true;      for (BagOfPrimitives[] row : elements) {        if (first) {          first = false;        } else {          sb.append(",");        }        boolean firstOfRow = true;        sb.append("[");        for (BagOfPrimitives element : row) {          if (firstOfRow) {            firstOfRow = false;          } else {            sb.append(",");          }          sb.append(element.getExpectedJson());        }        sb.append("]");      }      sb.append("]}");      return sb.toString();    }  }  public static class MyParameterizedType<T> {    private T value;    public MyParameterizedType(T value) {      this.value = value;    }    public T getValue() {      return value;    }    @SuppressWarnings("unchecked")    public String getExpectedJson() {      Class<T> clazz = (Class<T>) value.getClass();      boolean addQuotes = !clazz.isArray() && !Primitives.unwrap(clazz).isPrimitive();      StringBuilder sb = new StringBuilder("{\"");      sb.append(value.getClass().getSimpleName()).append("\":");      if (addQuotes) {        sb.append("\"");      }      sb.append(value.toString());      if (addQuotes) {        sb.append("\"");      }      sb.append("}");      return sb.toString();    }  }  public static enum MyEnum {    VALUE1, VALUE2;    public String getExpectedJson() {      return "\"" + toString() + "\"";    }  }  public static class ClassWithEnumFields {    private final MyEnum value1 = MyEnum.VALUE1;    private final MyEnum value2 = MyEnum.VALUE2;    public String getExpectedJson() {      return "{\"value1\":\"" + value1 + "\",\"value2\":\"" + value2 + "\"}";    }  }  public static class MyEnumCreator implements InstanceCreator<MyEnum> {    public MyEnum createInstance(Type type) {      return MyEnum.VALUE1;    }  }  public static class ClassWithPrivateNoArgsConstructor {    public int a;    private ClassWithPrivateNoArgsConstructor() {      a = 10;    }  }  public static class ClassOverridingEquals {    public ClassOverridingEquals ref;    public String getExpectedJson() {      if (ref == null) {        return "{}";      }      return "{\"ref\":" + ref.getExpectedJson() + "}";    }    @Override    public boolean equals(Object obj) {      return true;    }    @Override    public int hashCode() {      return 1;    }  }    public static class ClassWithExposedFields {    @Expose int a = 1;    int b = 2;        public String getExpectedJson() {      return '{' + "\"a\":" + a + '}';    }        public String getExpectedJsonWithoutAnnotations() {      return '{' + "\"a\":" + a + ",\"b\":" + b + '}';    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.TestTypes.BagOfPrimitives;import com.google.gson.TestTypes.ClassWithTransientFields;import com.google.gson.TestTypes.Nested;import com.google.gson.TestTypes.PrimitiveArray;import junit.framework.TestCase;import java.util.ArrayList;import java.util.List;public class JsonCompactFormatterTest extends TestCase {  private Gson gson;  @Override  protected void setUp() throws Exception {    super.setUp();    JsonFormatter formatter = new JsonCompactFormatter();    gson = new GsonBuilder().setFormatter(formatter).create();  }  @SuppressWarnings("unchecked")  public void testNoWhiteSpace() {    List list = new ArrayList();    list.add(new BagOfPrimitives());    list.add(new Nested());    list.add(new PrimitiveArray());    list.add(new ClassWithTransientFields());    String json = gson.toJson(list);    assertContainsNoWhiteSpace(json);  }  private void assertContainsNoWhiteSpace(String str) {    for (char c : str.toCharArray()) {      assertFalse(Character.isWhitespace(c));    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.MemoryRefStack;import junit.framework.TestCase;import java.util.EmptyStackException;/** * Unit tests for the {@link MemoryRefStack} class. * * @author Joel Leitch */public class MemoryRefStackTest extends TestCase {  private MemoryRefStack<MockObject> stack;  @Override  protected void setUp() throws Exception {    super.setUp();    stack = new MemoryRefStack<MockObject>();  }  public void testPeekEmptyStack() throws Exception {    try {      stack.peek();    } catch (EmptyStackException expected) { }  }  public void testPushPeekAndPop() throws Exception {    MockObject obj = new MockObject();    assertEquals(obj, stack.push(obj));    assertEquals(obj, stack.peek());    assertEquals(obj, stack.pop());  }  public void testPopTooMany() throws Exception {    MockObject obj = new MockObject();    stack.push(obj);    assertEquals(obj, stack.pop());    try {      stack.pop();    } catch (EmptyStackException expected) { }  }  public void testContains() throws Exception {    MockObject objA = new MockObject();    MockObject objB = new MockObject();    assertEquals(objA, objB);    stack.push(objA);    assertFalse(stack.contains(objB));    assertTrue(stack.contains(objA));  }  private static class MockObject {    private final int value = 1;    @Override    public boolean equals(Object obj) {      return obj instanceof MockObject && value == ((MockObject) obj).value;    }    @Override    public int hashCode() {      return value;    }  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.annotations.Expose;import junit.framework.TestCase;import java.lang.reflect.Field;/** * Unit tests for the {@link ExposeAnnotationBasedExclusionStrategy} class. * * @author Joel Leitch */public class ExposeAnnotationBasedExclusionStrategyTest extends TestCase {  private ExposeAnnotationBasedExclusionStrategy strategy;  @Override  protected void setUp() throws Exception {    super.setUp();    strategy = new ExposeAnnotationBasedExclusionStrategy();  }  public void testNeverSkipClasses() throws Exception {    assertFalse(strategy.shouldSkipClass(MockObject.class));  }    public void testSkipNonAnnotatedFields() throws Exception {    Field f = MockObject.class.getField("hiddenField");    assertTrue(strategy.shouldSkipField(f));  }    public void testNeverSkipExposedAnnotatedFields() throws Exception {    Field f = MockObject.class.getField("exposedField");    assertFalse(strategy.shouldSkipField(f));  }  private static class MockObject {    @Expose    public final int exposedField = 0;    public final int hiddenField = 0;  }}
/* * Copyright (C) 2008 Google Inc. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.google.gson;import com.google.gson.NullExclusionStrategy;import junit.framework.TestCase;/** * Unit test for the {@link NullExclusionStrategy} class. * * @author Joel Leitch */public class NullExclusionStrategyTest extends TestCase {  private NullExclusionStrategy strategy;  @Override  protected void setUp() throws Exception {    super.setUp();    strategy = new NullExclusionStrategy();  }  public void testNeverSkipsClass() throws Exception {    assertFalse(strategy.shouldSkipClass(String.class));  }  public void testNeverSkipsField() throws Exception {    assertFalse(strategy.shouldSkipField("".getClass().getFields()[0]));  }}